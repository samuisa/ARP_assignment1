# ARP_assignment1
This project implements a simulation of a drone moving in a 2D environment.

The architecture is composed of 6 separate processes. While the main application data flows through unnamed pipes, the system health is monitored by a dedicated Watchdog process using POSIX signals. 
These processes manage the overall logic, user input, the drone itself, obstacles, and targets within the 2D environment. The communication is managed by the main process, which creates the pipes and the child processes.
Our main processes, which have to manage more than one message at a time, use a select() call to efficiently monitor multiple file descriptors simultaneously. This allows each process to react only when new data becomes available on one of the pipes, avoiding unnecessary blocking enabling a responsive. Through this mechanism, the system can handle asynchronous interactions between components while maintaining low overhead and ensuring timely coordination among all processes.

<div align="center">
  <img src="/images/windows.png" alt="Diagramma Architettura Drone" width="900"/>
</div>


<br>**ARCHITECTURE AND PROCESSES**

<div align="center">
  <img src="/images/SketchARP.png" alt="Diagramma Architettura Drone" width="600"/>
</div>

**main** $\rightarrow$ This process handles initialization, creation of the pipes and the child processes, and waits for the termination of all processes. It also initializes the shared PID file used for system monitoring.

**blackboard** $\rightarrow$ This process acts as the system's server. It uses select() to simultaneously monitor the various pipes connected to the other processes. 

- Initialization: configures the ncurses environment and sends the window dimensions to the other processes (except to the input process).
- Visualization Update: updates the display of the drone (blue +), obstacles (red O), and targets(green T) when it receives their positions from each process.  
- When the input process sends the character from the user keyboard, Blackboard process forwards it to the drone process, which updates the drone force respecting the position of obstacles and edges.

The blackboard is also responsable of the dynamic environment where obstacles and targets evolve during the game. It makes disappear obstacles and targets (when the drone collapse with them) and it is responsable to send the new obstacle and target array to the drone process. 

**input** $\rightarrow$ This process displays a non-interactive ncurses legend detailing the keys the user can press. It captures the user's keystrokes and sends them to the blackboard process.

**drone** $\rightarrow$ The drone process calculates its new position, using the Euler's method, based on:

- Its internal dynamics.
- Manual forces sent by the user input.
- Repulsive force generated by obstacles and environment borders, computed using the Latombe model.
- Attractive force generated by targets

During execution, the process uses a select loop to react to multiple input sources (e.g., user commands, obstacle and target array, window size updated) without blocking, ensuring timely updates of the drone's state.

Finally, it sends its updated position to the blackboard process.

**obstacles** $\rightarrow$ This process generates a matrix of fixed obstacles based on a percentage of the window dimensions and sends this matrix to the blackboard process. Every 5 seconds, an existing obstacle is removed and a new one is spawned in a random position. The system ensures that new obstacles do not overlap with existing targets (this mechanism is guaranteed by the balckboard process). 

**targets** $\rightarrow$ This process generates the targets in the same manner as obstacles, ensuring they do not overlap with obstacles or borders, and sends them to the blackboar process. When the drone's coordinates overlap with a target, this one disappears from the map. This work for each targets until all target are reached by the drone and a new array of targets are generated and appers on the map (this mechanism is guarantieed by the balckboard process). 

<div align="center">
  <img src="/images/ARP_diagramma.png" alt="Diagramma Architettura Drone" width="600"/>
</div>

**watchdog** $\rightarrow$ A safety process that monitors the "liveness" of the entire system. When each process have written its pid on the shared register file "pid_registry", the watchodg works as follow:
- It reads the PIDs of all active processes.
- Every 2 seconds, it sends a SIGUSR1 to all processes.
- Each process have to respond sending a SIGUSR2 signal.
- If a process fails to respond with a SIGUSR2 within 200ms, the Watchdog assumes a crash and terminates the entire simulation using SIGKILL to ensure system safety.

<div align="center">
  <img src="/images/watchdog.png" alt="Funzionamento Watchdog" width="600"/>
</div>

<br>**ADDITIONAL FEATURES**
<br>As additional details for this project, a **Log File**, **Process Registry** and **Parameter Files** have been implemented.
<br>The log files are useful for tracking the general behavior of each processes in real-time. 
The parameter files store useful structs and system parameters necessary for the simulation processes.
<br>The **pid_registry.txt** is a shared file which stores the PIDs of all active components, allowing the Watchdog to track them without dedicated pipes.
<br>The **app_common.h** file is accessible from all processes and contains global variables and data structures, such as messages, the drone, and obstacles/targets. 
<br>Conversely, the **app_blackboard.h** file is accessible only from the Blackboard process and contains the dimensions of the main window, which are sent to all other processes through pipes. This is necessary because the obstacle and target processes compute the number of items they must generate as a percentage of **WIDTH * SIZE**, and the drone process needs these dimensions to check whether the drone collides with the walls.


<br>**PROJECT STRUCTURE**

```bash
.
├── exec
│   ├── blackboard
│   ├── drone
│   ├── input
│   ├── main
│   ├── obstacle
│   ├── target
│   └── watchdog
├── logs
│   ├── system.log
│   └── watchdog.log
├── Makefile
├── obj
│   ├── blackboard.o
│   ├── drone.o
│   ├── input.o
│   ├── log.o
│   ├── main.o
│   ├── obstacle.o
│   ├── target.o
│   └── watchdog.o
├── pid_registry.txt
└── src
    ├── app_blackboard.h
    ├── app_common.h
    ├── blackboard.c
    ├── drone.c
    ├── input.c
    ├── log.c
    ├── log.h
    ├── main.c
    ├── obstacle.c
    ├── process_pid.h
    ├── sium.c
    ├── target.c
    └── watchdog.c

```

<br>**HOW TO RUN THE SIMULATION**

To compile and launch the 2D Drone Simulation project, follow these steps in your terminal:
```bash
 make
```
<br>Once compiled, to execute the main program and open the separate ncurses windows (Input, Window/Blackboard):

```bash
 make run
```
<br>The simulation should now be active, displaying the drone environment and the input legend.
