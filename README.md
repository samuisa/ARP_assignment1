# ARP PROJECT
This project implements a simulation of a drone moving in a 2D environment.

The system supports two operating modes:
- Standalone Mode: All processes run locally on a single machine.
- Networked Mode: Two separate instances communicate via TCP Sockets. One instance acts as the Server and the other as the Client.

The architecture is composed of 7 separate processes. While the main application data flows through unnamed pipes, external synchronization in networked mode is handled via Sockets. The system health is monitored by a dedicated Watchdog process using POSIX signals. 
These processes manage the overall logic, user input, the drone itself, obstacles, and targets within the 2D environment. The communication is managed by the main process, which creates the pipes and the child processes.
Our main processes, which have to manage more than one message at a time, use a select() call to efficiently monitor multiple file descriptors simultaneously. This allows each process to react only when new data becomes available on one of the pipes, avoiding unnecessary blocking enabling a responsive. Through this mechanism, the system can handle asynchronous interactions between components while maintaining low overhead and ensuring timely coordination among all processes.

<div align="center">
  <img src="/images/windows.png" alt="Diagramma Architettura Drone" width="900"/>
</div>


<br>**ARCHITECTURE AND PROCESSES**

<div align="center">
  <img src="/images/SketchARP.png" alt="Diagramma Architettura Drone" width="600"/>
</div>

**main** $\rightarrow$ This process handles initialization, menu selection for Mode (Standalone/Networked) and Role (Server/Client), creation of the pipes and the child processes, and waits for the termination of all processes. It also initializes the shared PID file used for system monitoring.

**blackboard** $\rightarrow$ This process acts as the system's server. It uses select() to simultaneously monitor the various pipes connected to the other processes. 

- Initialization: configures the ncurses environment and sends the window dimensions to the other processes (except to the input process).
- Visualization: updates the display of the drone (blue +), obstacles (red O), and targets(green T) when it receives their positions from each process.  
- When the input process sends the character from the user keyboard, Blackboard process forwards it to the drone process, which updates the drone force respecting the position of obstacles and edges.
- Networking Integration: In networked mode, it synchronizes window dimensions between the Server and Client. It also receives the remote drone's coordinates and displays them as a dynamic obstacle.

The blackboard is also responsable, for standalone mode, of the dynamic environment where obstacles and targets evolve during the game. It makes disappear obstacles and targets (when the drone collapse with them) and it is responsable to send the new obstacle and target array to the drone process. 

**input** $\rightarrow$ This process displays a non-interactive ncurses legend detailing the keys the user can press. It captures the user's keystrokes and sends them to the blackboard process.

**drone** $\rightarrow$ The drone process calculates its new position, using the Euler's method, based on:

- Its internal dynamics.
- Manual forces sent by the user input.
- Repulsive force generated by obstacles and environment borders, computed using the Latombe model.
- Attractive force generated by targets

During execution, the process uses a select loop to react to multiple input sources (e.g., user commands, obstacle and target array, window size updated) without blocking, ensuring timely updates of the drone's state.

Finally, it sends its updated position to the blackboard process.

**obstacles** $\rightarrow$ 
- in Standaloine mode, this process generates a matrix of fixed obstacles based on a percentage of the window dimensions and sends this matrix to the blackboard process. Every 5 seconds, an existing obstacle is removed and a new one is spawned in a random position. The system ensures that new obstacles do not overlap with existing targets (this mechanism is guaranteed by the balckboard process).
- in Networking mode, the obstacles dont'appear, only the remote drone effectively acts as the obstacle for the local instance.

**targets** $\rightarrow$ 
- in Standaloine mode, this process generates the targets in the same manner as obstacles, ensuring they do not overlap with obstacles or borders, and sends them to the blackboar process. When the drone's coordinates overlap with a target, this one disappears from the map. This work for each targets until all target are reached by the drone and a new array of targets are generated and appers on the map (this mechanism is guarantieed by the balckboard process).Targets are strictly numbered and must be reached in sequence; hitting a target out of order will cause it to be randomly repositioned on the map.
- in Networking mode, the targets don't appear.

<div align="center">
  <img src="/images/ARP_diagramma.png" alt="Diagramma Architettura Drone" width="600"/>
</div>

**watchdog** $\rightarrow$ A safety process that monitors the "liveness" of the entire system. When each process have written its pid on the shared register file "pid_registry", the watchodg works as follow:
- It reads the PIDs of all active processes.
- Every 2 seconds, it sends a SIGUSR1 to all processes.
- Each process have to respond sending a SIGUSR2 signal.
- If a process fails to respond with a SIGUSR2 within 200ms, the Watchdog assumes a crash and terminates the entire simulation using SIGKILL to ensure system safety.

<div align="center">
  <img src="/images/watchdog.png" alt="Funzionamento Watchdog" width="600"/>
</div>

**network** $\rightarrow$ Manages the TCP connection and implements a strict Request-Response protocol.
- Non-Blocking I/O: Uses select() and non-blocking sockets to ensure communication does not freeze the local simulation.
- Handshake: Sincronizes game start and window sizes between peers.
- Virtual Coordinates: Maps local ncurses coordinates to a "virtual" space, allowing users with different terminal sizes to play together seamlessly.

<br>**NETWORK PROTOCOL**<br>
The network process follows a strict string-based protocol via TCP:
1) Handshake: Exchange of ok and size messages to verify the connection.
2) Drone Sync: Sequential exchange of drone commands followed by x y coordinates.
3) Obstacle Sync: Requests for obstacle data via obst followed by the peer's drone position.
4) Acknowledgment: Every data transmission is followed by an ack (e.g., dok or pok).

<br>**ADDITIONAL FEATURES**
<br>As additional details for this project, a **Log File**, **Process Registry** and **Parameter Files** have been implemented.
<br>The log files are useful for tracking the general behavior of each processes in real-time. 
The parameter files store useful structs and system parameters necessary for the simulation processes.
<br>The **pid_registry.txt** is a shared file which stores the PIDs of all active components, allowing the Watchdog to track them without dedicated pipes.
<br>The **app_common.h** file is accessible from all processes and contains global variables and data structures, such as messages, the drone, and obstacles/targets. 
<br>Conversely, the **app_blackboard.h** file is accessible only from the Blackboard process and contains the dimensions of the main window, which are sent to all other processes through pipes. This is necessary because the obstacle and target processes compute the number of items they must generate as a percentage of **WIDTH * SIZE**, and the drone process needs these dimensions to check whether the drone collides with the walls.


<br>**PROJECT STRUCTURE**

```bash
.
├── exec
│   ├── blackboard
│   ├── client
│   ├── drone
│   ├── input
│   ├── main
│   ├── network
│   ├── obstacle
│   ├── server
│   ├── target
│   └── watchdog
├── logs
│   ├── server_client.log
│   ├── system.log
│   └── watchdog.log
├── Makefile
├── obj
│   ├── app_common.o
│   ├── blackboard.o
│   ├── drone.o
│   ├── input.o
│   ├── log.o
│   ├── main.o
│   ├── network.o
│   ├── obstacle.o
│   ├── target.o
│   └── watchdog.o
├── pid_registry.txt
└── src
    ├── app_blackboard.h
    ├── app_common.c
    ├── app_common.h
    ├── blackboard.c
    ├── drone.c
    ├── input.c
    ├── log.c
    ├── log.h
    ├── main.c
    ├── network_block.c
    ├── network.c
    ├── obstacle.c
    ├── process_pid.h
    ├── target.c
    └── watchdog.c

```

<br>**HOW TO RUN THE SIMULATION**

1) Compile<br>
```bash
 make
```
2) Run<br>
```bash
 make run
```
3) Configuration<br> 
- choose 1 for Standalone or 2 for Networked.
- if Networked, select your role: 1 for Server (listens for connections) or 2 for Client (connects to an IP).
- clients must provide the Server's IP address and Port Number.

<br>**INFOs FOR TESTING**<br>
Code tested the 15/01/2026 with 2 groups. <br>
1° Group: Antonio Zerbato  <br>
2° Group: Arianna Bardoni & Antonio Mazzotta
